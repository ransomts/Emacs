#+AUTHOR: Tim Ransom
#+TITLE: emacs configuration

* Add load path

  Here we start off with some black magic. Lexical bindings let me use a higher order functions when elisp's dynamic bindings don't. 
  #+BEGIN_SRC emacs-lisp
    ;; -*- lexical-binding: t -*-
  #+END_SRC

  Just a couple of functions to help sort what machine and network the config is being loaded on. So long as the emacs version is >24 I think this should be sufficient to use filter packages and settings between setups.
  #+BEGIN_SRC emacs-lisp
    (defun running-on-hosts (hosts)
      (member
       (car (split-string ; split the hostname on '.' for complex hostnames
	     (car (split-string ; remove trailing newline from `hostname`
		   (shell-command-to-string "hostname") "\n")) "\\."))
       hosts))

    (defun running-on-wireless (essids)
      (member (shell-command-to-string "iwgetid --raw") essids))
  #+END_SRC

  One last bootstrap, gotta load up use-package for good load times. This also adds any directories that might not be available through the usual methods like dired+.
  #+BEGIN_SRC emacs-lisp
    (let ((default-directory  "~/.emacs.d/packages/"))
      (normal-top-level-add-subdirs-to-load-path))

    (require 'use-package)
  #+END_SRC

* Packages
** Built In
*** gnus

    I use gnus mostly as an rss reader, but have the email there too if I want to fire off a quick note.
    #+BEGIN_SRC emacs-lisp
      (use-package gnus
	:bind ("C-M-g" . #'gnus)
	:config
	(setq
	 gnus-always-read-dribble-file t
	 gnus-directory "~/.emacs.d/gnus"))
    #+END_SRC

**** TODO scan daemon
     #+BEGIN_SRC emacs-lisp
     ;; (use-package gnus-demon
     ;;   :ensure t
     ;;   :hook
     ;;   (gnus-demon-add-handler #'gnus-demon-scan-news 2 nil)
     ;;   (message "from hook")
    ;;   )
     #+END_SRC

*** org
    #+BEGIN_SRC emacs-lisp
		  (use-package org
			  :config
			  (setq diary-file "~/.emacs.d/org/schedule.org"
			  org-agenda-files
			  '("~/.emacs.d/org/fun/code-ideas.org"
				  "~/.emacs.d/org/fun/music.org"
				  "~/.emacs.d/org/scratch.org"
				  "~/.emacs.d/org/research.org"
				  "~/.emacs.d/org/schedule.org"
				  "~/.emacs.d/org/todo.org")
			  org-agenda-use-time-grid nil
			  org-archive-location "~/.emacs.d/org/archive.org::* From %s"
			  org-babel-load-languages
			  '((emacs-lisp . t)
				  (awk . t)
				  (ditaa . t)
				  (lisp . t)
				  (haskell . t)
				  (C . t)
				  (gnuplot . t)
				  (python . t)
				  (shell . t)
				  (sqlite . t)
				  (java . t))
			  org-capture-after-finalize-hook nil
			  org-capture-templates '(("t" "Todo" entry
						   (file+headline "~/.emacs.d/org/todo.org" "Tasks")
						   "* TODO %?
							  Entered on %T
							   %i
							   %a")
						  ("e" "Event" entry
						   (file "~/.emacs.d/org/schedule.org")
						   "* %?
							  Date %^t")
						  ("b" "Fix Bug" checkitem
						   (file+headline "~/.emacs.d/org/todo.org" "Bugs")
						   "[ ] %?
							  %A
							  Entered on %T")
						  ("n" "General notes" entry
						   (file+headline "~/.emacs.d/org/scratch.org" "Notes")
						   "* Note %?
							   %T
							  "))
			  org-clock-sound t
			  org-confirm-babel-evaluate nil
			  org-datetree-add-timestamp 'inactive
			  org-default-notes-file "~/.emacs.d/org/todo.org"
			  org-directory "~/.emacs.d/org"
			  org-gcal-client-secret "UwfWeXumob8oMLGTBs2D6D5j"
			  org-gcal-dir "~/.emacs.d/org/org-gcal/"
			  org-hide-leading-stars t
			  org-highlight-latex-and-related '(latex)
			  org-journal-dir "~/.emacs.d/org/journal"
			  org-log-done 'time
			  org-outline-path-complete-in-steps nil
			  org-preview-latex-image-directory "~/.emacs.d/ltxpng/"
			  org-refile-targets '((org-agenda-files :maxlevel . 2))
			  org-refile-use-outline-path 'file
			  org-startup-with-latex-preview t
			  org-todo-keyword-faces
			  '(("SOON"
				   :foreground "blue"
				   :background "sky blue"
				   :weight bold)
				  ("DONE"
				   :foreground "darkseagreen4"
				   :background "darkseagreen2"
				   :weight bold))
			  org-todo-keywords '((sequence "TODO" "SOON" "DONE")))
			  :bind
			  (
			   ("C-c a" . #'org-agenda)
			   ("C-c c" . #'org-capture)
			   (:map org-mode-map
			   (("C-c r" . #'org-archive-subtree)
				  ("C-c C-r" . #'org-archive-subtree)))))
    #+END_SRC

**** bullets
     #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :ensure t
      :hook (org-mode . org-bullets-mode))
     #+END_SRC

*** erc

    IRC is a really valuable resource that is being used less and less. Having people to answer random technical questions is so nice when working on something and nobody around can help.
    #+BEGIN_SRC emacs-lisp
    (use-package erc
	  :config
	  (setq
	   erc-autojoin-channels-alist (quote (("freenode.net")))
	   erc-autojoin-mode nil
	   erc-autojoin-timing (quote ident)
	   erc-hide-list (quote ("JOIN" "PART" "NICK" "QUIT"))
	   erc-hide-timestamps t
	   erc-list-mode t
	   erc-log-channels-directory "~/.emacs.d/erc_log"
	   erc-log-mode t
	   erc-log-write-after-insert t
	   erc-log-write-after-send t
	   erc-modules
	   '(autojoin button completion dcc fill irccontrols keep-place
	     list log match menu move-to-prompt netsplit networks
	     noncommands notifications readonly ring services sound
	     stamp track)
	   erc-nick "Timzi"
	   erc-prompt "<Timzi>"
	   erc-sound-mode t))
    #+END_SRC

*** dired
  #+BEGIN_SRC emacs-lisp
  (use-package dired+
    :bind (:map dired-mode-map
		(("M-h" . #'dired-omit-mode)
		 ("u" . #'dired-up-directory)))
    :config
    (setq
     dired-listing-switches "-alh --no-group"
     dired-no-confirm '(byte-compile copy delete)
     dired-omit-files "^\\..*~?$"
     dired-recursive-copies 'always
     dired-recursive-deletes 'always))
  #+END_SRC

** External

*** Dad-joke

    This is top tier package-age here.
    #+BEGIN_SRC emacs-lisp
  (use-package dad-joke :ensure t)
    #+END_SRC

*** Theme

    I really like themes that have light and dark modes. The material theme fits that and has been my theme of choice for a few years.
    #+BEGIN_SRC emacs-lisp
  (use-package material-theme
    :if (not (running-on-hosts '("login001")))
    :ensure t
    :config
    (load-theme 'material t))
    #+END_SRC

    Switch between the light and dark modes on sunrise and sunset. Lets me know what the sun is doing even when I spend all day inside :)
    #+BEGIN_SRC emacs-lisp
      (use-package theme-changer
	:if (not (running-on-hosts '("login001")))
	:ensure t
	:init
	(setq calendar-latitude 34.67
	      calendar-location-name "Clemson, SC"
	      calendar-longitude -82.84)
	:config (change-theme 'material-light 'material))
    #+END_SRC

*** helm

    Helm is really a game changer for emacs. More over, it's the helm extensions that can really turn something tedious to easy.
    #+BEGIN_SRC emacs-lisp
      (use-package helm
	:ensure t
	:bind (("M-x" . #'helm-M-x)
	       ("C-x b" . #'helm-buffers-list)
	       ("C-x f" . #'helm-find-files)
	       ("C-x C-f" . #'helm-find-files))
	:config
	(helm-mode t))
    #+END_SRC

**** tramp

     Reads in [[file:~/.ssh/config][my ssh config]] and connects me without needing to remember the trmp syntax.
     #+BEGIN_SRC emacs-lisp
  (use-package helm-tramp
      :if (not (running-on-hosts '("login001")))
      :ensure t
      :after (helm))
     #+END_SRC

**** bbdb

     This seems to be the most accepted way to manage contact info with emacs. It works well with mail and gnus though so it's okay with me.
     #+BEGIN_SRC emacs-lisp
    (use-package helm-bbdb
      :if (not (running-on-hosts '("login001")))
      :ensure t
      :after (helm)
      :bind (("<f5>" . #'helm-bbdb)))
     #+END_SRC

**** TODO dictionary

     Every computer used for writing should have a dictionary available by keystroke.
     #+BEGIN_SRC emacs-lisp
    (use-package helm-dictionary
          :if (not (running-on-hosts '("login001")))
	  :ensure t
	  :after (helm)
	  :bind (("<f8>" . #'helm-dictionary))
	  :config
	  (setq
	   helm-dictionary-browser-function 'browse-url-firefox
	   helm-dictionary-database "/usr/share/dict/words"
	   helm-dictionary-online-dicts
	   '(("wiktionary" . "http://en.wiktionary.org/wiki/%s")
	     ("Oxford English Dictionary" . "www.oed.com/search?searchType=dictionary&q=%s")
	     ("Merriam-Webster" . "https://www.merriam-webster.com/dictionary/%s"))
	   helm-dictionary-use-full-frame nil))
     #+END_SRC

*** magit

    Great way to interact with git. Not much config needed, just a global keybinding to pop open the status.
    #+BEGIN_SRC emacs-lisp
	  (use-package magit
		  :ensure t
		  :bind ("C-x g" . #'magit-status))
    #+END_SRC

*** pdf
    #+BEGIN_SRC emacs-lisp
      (use-package pdf-tools
	:ensure t
	:if (not (or (string= nil (getenv "DESKTOP_SESSION")) 
		     (running-on-hosts '("login001"))))
	:load-path "site-lisp/pdf-tools/lisp"
	:magic ("%PDF" . pdf-view-mode)
	:config
	(pdf-tools-install)
	(setq pdf-misc-print-programm "/usr/bin/gtklp"))
    #+END_SRC

*** TODO dashboard

    This dashboard pairs really well with exwm but has been a bit of a pain to set up.
    For now I'm still choosing an org-mode scratch buffer but this is a todo.
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
	:ensure t)
      (use-package page-break-lines
	:ensure t)
      (use-package dashboard
	:ensure t
	:after (projectile page-line-breaks)
	:config
	(dashboard-setup-startup-hook)
	(setq dashboard-items '((recents  . 5)
				(bookmarks . 5)
				(projects . 5)
				(agenda . 5)
				(registers . 5))))
    #+END_SRC

*** transmission
    #+BEGIN_SRC emacs-lisp
      (use-package transmission
	    :ensure t
	    :if (running-on-hosts '("joseki" "tengen"))
	    :config
	    (setq
	     transmission-refresh-modes
	     '(transmission-mode
	       transmission-files-mode
	       transmission-info-mode
	       transmission-peers-mode)))
    #+END_SRC

*** emms
    #+BEGIN_SRC emacs-lisp
	  (use-package emms
	    :if (running-on-hosts '("joseki" "tengen"))
	    :ensure t
	    :config
	    (setq
	     emms-cache-get-function 'emms-cache-get
	     emms-cache-modified-function 'emms-cache-dirty
	     emms-cache-set-function 'emms-cache-set
	     emms-info-functions '(emms-info-mediainfo
							   emms-info-mpd emms-info-cueinfo
							   emms-info-ogginfo)
	     emms-mode-line-cycle t
	     emms-mode-line-mode-line-function 'emms-mode-line-cycle-mode-line-function
	     emms-player-mpd-music-directory "/home/tsranso/Music"
	     emms-player-mplayer-command-name "mpv"
	     emms-player-next-function 'emms-score-next-noerror
	     emms-playlist-default-major-mode 'emms-playlist-mode
	     emms-playlist-update-track-function 'emms-playlist-mode-update-track-function
	     emms-track-description-function 'emms-info-track-description))
    #+END_SRC

*** bbdb
    #+BEGIN_SRC emacs-lisp
    (use-package bbdb
	  :config ()
	  (setq
	   bbdb-dial-function
	   (lambda
	     (phone-number)
	     (kdeconnect-send-sms
		  (read-string "Enter message: ")
		  (string-to-int
		   (replace-regexp-in-string "[() -]" "" phone-number))))))
    #+END_SRC

*** slime

    Everybody who wants to dive into lisp should use slime. Even if just for learning differences between the lisps, slime is the way to go for lisp dev.
    #+BEGIN_SRC emacs-lisp
    (use-package slime
	  :ensure t
	  :config
	  (setq inferior-lisp-program "sbcl")
	  slime-contribs '(slime-fancy))
    #+END_SRC

*** fill column indicator
    #+BEGIN_SRC emacs-lisp
      (use-package fill-column-indicator
	:ensure t
	:config
	(setq
	 fci-rule-column 80
	 fill-column 80))
    #+END_SRC

*** smart mode line
    #+BEGIN_SRC emacs-lisp
      (use-package smart-mode-line
	:ensure t
	:init 
	(setq sml/theme 'respectful
	      sml/no-confirm-load-theme t)
	:config (sml/setup))
    #+END_SRC

*** gnuplot

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot :ensure t)
#+END_SRC

* exwm

  #+BEGIN_SRC emacs-lisp
    (defun launch-program (command)
      (interactive (list (read-shell-command "$ ")))
      (start-process-shell-command command nil command))

    (defun lock-screen ()
      (interactive)
      (shell-command "/usr/local/bin/lock.sh"))

    (use-package xelb 
      :if (string= "exwm" (getenv "DESKTOP_SESSION"))
      :ensure t)

    (use-package exwm
      :if (string= "exwm" (getenv "DESKTOP_SESSION"))
      :ensure t
      :after (xelb)
      :bind
      (("s-x" . #'launch-program)
       ("s-l" . #'lock-screen)
       ("s-w" . #'exwm-workplace-switch)
       ("s-r" . #'exwm-reset)
       ("C-x C-c" . #'save-buffers-kill-emacs))
      :config
      (setq exwm-input-simulation-keys
	    '(([?\C-b] . [left])
	      ([?\C-f] . [right])
	      ([?\C-p] . [up])
	      ([?\C-n] . [down])
	      ([?\C-a] . [home])
	      ([?\C-e] . [end])
	      ([?\M-v] . [prior])
	      ([?\C-v] . [next])
	      ([?\C-d] . [delete])
	      ([?\C-h] . [backspace])
	      ([?\C-m] . [return])
	      ([?\C-i] . [tab])
	      ([?\C-g] . [escape])
	      ([?\M-g] . [f5])
	      ([?\C-s] . [C-f])
	      ([?\C-y] . [C-v])
	      ([?\M-w] . [C-c])
	      ([?\M-<] . [home])
	      ;; todo ([?\M-o] . [C-x o])
	      ([?\M->] . [C-end])))

      (global-set-key (kbd "<mouse-12>") (lambda () (interactive)
					   (exwm-input--fake-key 26)))

      (dolist (k '(
		   ("s-<return>" . "urxvtc")
		   ("s-p" . "nemo")
		   ("s-d" . "discord")
		   ("s-t" . "transmission-remote-gtk")
		   ("s-s" . "slack")
		   ("s-<tab>" . "google-chrome-stable")
		   ("<C-M-escape>" . "gnome-system-monitor")
		   ("s-m" . "pavucontrol")
		   ("s-<down>" . "amixer sset Master 5%-")
		   ("s-<up>" . "amixer set Master unmute; amixer sset Master 5%+")
		   ("<print>" . "scrot")
		   ("<XF86MonBrightnessUp>" . "light -A 10")
		   ("<XF86MonBrightnessDown>" . "light -U 10")
		   ("<XF86AudioMute>"."amixer set Master toggle")
		   ("<XF86AudioLowerVolume>" . "amixer sset Master 5%-")
		   ("<XF86AudioRaiseVolume>" . "amixer set Master unmute; amixer sset Master 5%+")))
	(let ((f (lambda () (interactive)
		   (save-window-excursion
		     (start-process-shell-command "" nil (cdr k))))))
	  (exwm-input-set-key (kbd (car k)) f)))

      (require 'exwm-systemtray)
      (exwm-systemtray-enable)

      (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
      (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

      (add-hook 'exwm-update-title-hook 
		(lambda () (exwm-workspace-rename-buffer exwm-title)))

      (setq exwm-workspace-number 10
	    exwm-workspace-show-all-buffers t
	    exwm-layout-show-all-buffers t)

      (dotimes (i 10)
	(exwm-input-set-key (kbd (format "s-%d" i))
			    `(lambda ()
			       (interactive)
			       (exwm-workspace-switch-create ,i))))

      (push ?\C-q exwm-input-prefix-keys)
      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

      (require 'exwm-randr)
      (when (running-on-hosts '("tengen"))
	(setq exwm-randr-workspace-output-plist
	      '(0 "DP-2" 9 "DP-2" 8 "DP-2" 7 "DP-2" 6 "DP-2"
		  1 "HDMI-3" 2 "HDMI-3" 3 "HDMI-3" 4 "HDMI-3" 5 "HDMI-3"))
	(add-hook 'exwm-randr-screen-change-hook
		  (lambda ()
		    (start-process-shell-command
		     "xrandr" nil
		     (concat "xrandr "
			     "--output DP-2 --mode 1600x900 --pos 1920x180 "
			     "--output HDMI-3 --mode 1920x1080 --pos 0x0 ")))))

      (when (running-on-hosts '("206"))
	(setq exwm-randr-workspace-output-plist
	      '(0 "DP-2" 9 "DP-2" 8 "DP-2" 7 "DP-2" 6 "DP-2"
		  1 "DP-1" 2 "DP-1" 3 "DP-1" 4 "DP-1" 5 "DP-1"))
	(add-hook 'exwm-randr-screen-change-hook
		  (lambda ()
		    (start-process-shell-command
		     "xrandr" nil
		     (concat "xrandr "
			     "--output DP-2 --mode 1920x1080 --pos 1920x0 "
			     "--output DP-1 --primary --mode 1920x1080 --pos 0x0")))))

      (exwm-randr-enable)
      (exwm-enable))
  #+END_SRC

** Autostart programs

   I use this config across several machines, depending which machine and what network it's connected to I want different autostart applications.
    #+BEGIN_SRC emacs-lisp :noweb yes
      (when (running-on-hosts '("joseki"))
	(display-battery-mode t)
	(start-process "" nil "xrdb" "-merge" "/home/tsranso/.config/urxvt/conf")
	(start-process "wifi applet" nil "nm-applet")
	(start-process "redshift" nil "redshift-gtk")

	(when (running-on-wireless '("Torus Shaped Earth\n"))
	  (start-process "discord" nil "discord")
	  (start-process "transmission"
			 nil "transmission-daemon")))

      (when (running-on-hosts '("206"))
	(start-process "bluetooth applet" nil "blueman-applet")
	(start-process "redshift" nil "redshift-gtk"))


      (when (running-on-hosts '("joseki" "206"))
	(unless (file-exists-p "~/.config/mpd/pid")			 
	  (start-process "music player daemon" nil "mpd")))

      (when (not (running-on-hosts '("atari" "login001")))
		 (start-process "urxvt daemon" nil "urxvtd" "-f" "-q" "-o")
		 (start-process "syncthing" nil "syncthing")
		 (start-process "xautolock" nil
				"xautolock"
				"-time 10"
				"-locker lock.sh"))

      (when (not (running-on-hosts '("login001")))
	(start-process "unclutter" nil "unclutter"))


    #+END_SRC

* Moving around

  Here are just about my only modifications to ordinary bindings. Mostly just convienience and intution things.
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-o")     #'other-window)
    (global-set-key (kbd "M-h")     #'backward-kill-word)                   
    (global-set-key (kbd "C-x k")   #'kill-this-buffer)                     
    (global-set-key (kbd "C-x C-k") #'kill-this-buffer)                     
    (global-set-key (kbd "C-h")     #'delete-backward-char)                 
    (global-set-key (kbd "C-x 2")                                           
		    (lambda ()                                              
		      (interactive)                                         
		      (split-window-vertically)                             
		      (other-window 1)))    
  #+END_SRC

* Buffer Management
** transpose windows

   Transposing is surprisingly not a built in function. Here's something that lets me move the current buffer around in the frame.
   #+BEGIN_SRC emacs-lisp
      (defun transpose-windows (arg)
        "Transpose the buffers shown in two windows."
        (interactive "p")
        (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
          (while (/= arg 0)
            (let ((this-win (window-buffer))
                  (next-win (window-buffer (funcall selector))))
              (set-window-buffer (selected-window) next-win)
              (set-window-buffer (funcall selector) this-win)
              (select-window (funcall selector)))
            (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

      (global-set-key (kbd "C-x t") #'transpose-windows)
   #+END_SRC

** toggle frame split

   Likewise switching from vertical to horizantal (and back). Really should be built it.
   #+BEGIN_SRC emacs-lisp
	  (defun toggle-frame-split ()
		"If the frame is split vertically, split it horizontally or vice versa.
	  Assumes that the frame is only split into two."
		(interactive)
		(unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
		(let ((split-vertically-p (window-combined-p)))
		  (delete-window) ; closes current window
		  (if split-vertically-p
			  (split-window-horizontally)
			(split-window-vertically))
		  (switch-to-buffer nil)))

	  (global-set-key (kbd "C-x |") 'toggle-frame-split)
   #+END_SRC

* general emacs settings
** asynchronous
   Gotta use the few async operations we have
   #+BEGIN_SRC emacs-lisp
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
(async-bytecomp-package-mode 1)
   #+END_SRC

** time and date
   #+BEGIN_SRC emacs-lisp
     (setq calendar-mark-diary-entries-flag t
	   display-time-24hr-format t
	   display-time-default-load-average nil)

     (display-time-mode t)
   #+END_SRC

** window behavior
   #+BEGIN_SRC emacs-lisp
  ;; (setq 
  ;;       use-dialog-box nil
  ;;       line-number-mode t
  ;;       column-number-mode t)

  (tooltip-mode 0)
  (fringe-mode 1)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
   #+END_SRC

   #+RESULTS:

** cursor behavior
   #+BEGIN_SRC emacs-lisp
     (setq x-stretch-cursor t
	   sentence-end-double-space nil
	   tab-width 4)

     (show-paren-mode t)
   #+END_SRC

** trash behavior
   #+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t
		trash-directory "/home/tsranso/.local/share/Trash/files/")
   #+END_SRC

** initialization
   #+BEGIN_SRC emacs-lisp
   (setq 
    ;initial-buffer-choice (lambda nil (get-buffer "*dashboard*"))
    initial-buffer-choice (lambda nil (get-buffer "*scratch*"))
    initial-major-mode 'org-mode
    initial-scratch-message (concat (format-time-string "%Y-%m-%d")
 "

 "))
   #+END_SRC

** proced
   #+BEGIN_SRC emacs-lisp
  (setq proced-auto-update-flag t
		proced-auto-update-interval 2
		proced-filter 'user)
   #+END_SRC

** browser
   #+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-firefox
		browse-url-firefox-arguments '("-new-window")
		browse-url-firefox-startup-arguments nil)
   #+END_SRC

** doc view
   #+BEGIN_SRC emacs-lisp
  (setq doc-view-continuous t
		doc-view-resolution 300)
   #+END_SRC

** file backup info
   #+BEGIN_SRC emacs-lisp
(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "/var/emacs/"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups

(recentf-mode 1)
   #+END_SRC

** misc
   #+BEGIN_SRC emacs-lisp
		 (global-set-key (kbd "<f6>")    #'calc)
		 (global-set-key (kbd "<f7>")    #'calendar)
		 (global-set-key (kbd "C-x e")   #'eshell)
		 (global-set-key (kbd "C-c C-c") #'compile)
		 (global-set-key (kbd "C-c r")   #'revert-buffer)


		 (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
					 async-bytecomp-package-mode t
					 gdb-many-windows t
					 large-file-warning-threshold 500000000
					 send-mail-function 'smtpmail-send-it
					 message-directory "~/.emacs.d/Mail/"
							 ;tramp-histfile-override "/dev/null" nil (tramp)
					 )
   #+END_SRC

